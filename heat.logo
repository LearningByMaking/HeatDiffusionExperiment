to heat-exp
  print "|starting heat experiment|
  init
  loop [        
	talkto 19
        see-packet     
        talkto 20
        see-packet
        wait 200 
       ]
end

to init
  Xinit-data
  set-calibration
  start-appboard
end

to Xinit-data
;  setup-screen
  make "slope-list []
  make "data-list []  
  make "alpha 0.03         ; adjust constant to match simulation to real data
  make "first-time true
  make "heat-list []
  make "real-list []
  make "start-time now       ; gets the unit time at the begining of the experiment

  make "check60 0
  make "check61 0
end

to set-calibration
  make "temp0_cal [500 22.0 1000 50.0]     ; pairs (adc,temp)
  make "temp1_cal [500 22.0 1000 50.0]     ; pairs (adc,temp)
  make "temp2_cal [500 22.0 1000 50.0]     ; pairs (adc,temp)
  make "temp3_cal [500 22.0 1000 50.0]     ; pairs (adc,temp)
end

to start-appboard

  talkto 19
  wait 5
  ul-ready
  ul-set

  talkto 20
  wait 5
  ul-ready
  ul-set

  talkto 19
  wait 5
  ul-go

  talkto 20
  wait 5
  ul-go

end
  

to see-packet
   make "packet-bytes rl $1fc0 30   ; add checksum and ignore if not new

   if (count :packet-bytes) > 0 
	[
             process-packet
             ;make "ncol 6
             ;make "data-list :heat-list
             ;save-data "heatreal-list.txt 
	]
    
end

to process-packet  
  make "type nth 1 :packet-bytes 
  print-packet  
  if (:type = 60)
  [
    process-heat-packet
  ]
  if (:type = 61)
  [
    process-light-packet
  ]
  
end

to process-heat-packet
  let [th 0]
  let [tl 0]
  make "oldcheck :check60
  let [nws ((first :packet-bytes) / 2) + 2]
  make "check60 wnth :nws :packet-bytes
  print (se :check60 :oldcheck)
  if not (:check60 = :oldcheck) [
    make "type nth 1 :packet-bytes
    make "wp packet-words :packet-bytes
    print ( se word "T bf 100 + :type round now / 1000 :wp  )    
    make "th wnth 2 :packet-bytes         ; timestamph from packet
    make "tl wnth 3 :packet-bytes         ; timestampl from packet

; grab values from packet
  if (:type = 60) [
    make "elapse round ((now - :start-time) / 1000) ; elapsed time (sec)
    make "day-night wnth 4 :packet-bytes
    make "temp0     wnth 5 :packet-bytes
    make "temp1     wnth 6 :packet-bytes
    make "temp2     wnth 7 :packet-bytes
    make "temp3     wnth 8 :packet-bytes

    make "heat-list se :heat-list :elapse

    make "day-night 10 * :day-night + 5
    make "heat-list se :heat-list :day-night

    make "temp0 calibrate :temp0 :temp0_cal
    make "temp1 calibrate :temp1 :temp1_cal
    make "temp2 calibrate :temp2 :temp2_cal
    make "temp3 calibrate :temp3 :temp3_cal

    make "heat-list se :heat-list :temp0
    make "heat-list se :heat-list :temp1
    make "heat-list se :heat-list :temp2
    make "heat-list se :heat-list :temp3
    make "ncol 6       ;elapse, day-night, temp0, temp1, temp2, temp3
    
    plot-temp
    display
   ]
  ]
end

to print-packet
  make "wp packet-words :packet-bytes
  print ( se word "T bf 100 + :type round now / 1000 :wp  ) 
end

to Xprocess-heat-packet
  print "|HEAT PACKET|
  
  make "th wnth 2 :packet-bytes         ; timestamph from packet
  make "tl wnth 3 :packet-bytes         ; timestampl from packet

  make "elapse round ((now - :start-time) / 1000) ; elapsed time (sec)
  make "day-night wnth 4 :packet-bytes
  make "temp0     wnth 5 :packet-bytes
  make "temp1     wnth 6 :packet-bytes
  make "temp2     wnth 7 :packet-bytes
  make "temp3     wnth 8 :packet-bytes

  make "heat-list se :heat-list :elapse

  make "day-night 10 * :day-night + 5
  make "heat-list se :heat-list :day-night

  make "temp0 calibrate :temp0 :temp0_cal
  make "temp1 calibrate :temp1 :temp1_cal
  make "temp2 calibrate :temp2 :temp2_cal
  make "temp3 calibrate :temp3 :temp3_cal

  make "heat-list se :heat-list :temp0
  make "heat-list se :heat-list :temp1
  make "heat-list se :heat-list :temp2
  make "heat-list se :heat-list :temp3
  make "ncol 6       ;elapse, day-night, temp0, temp1, temp2, temp3 
  plot-hist
end

to calibrate :n :m
  let [adc0 nth 0 :m]
  let [adc1 nth 2 :m]
  let [val0 nth 1 :m]
  let [val1 nth 3 :m]
  let [slope (:val1 - :val0) / (:adc1 - :adc0)] ;later find the correct pair - assume one point for now
  output  ((:n - :adc0) * :slope) + :val0
end

to process-light-packet
 print "|LIGHT PACKET|
end




to plot-hist
ltype 1      ; black white lines
ptype 2      ; circles
clean

make "xcol-data :val-list
make "savexupper xupper

make "savexlower xlower
make "binsize (:savexupper - :savexlower) / 50

bin :savexlower :savexupper :binsize    ;builds bins in "xcol-data
hist :avg-list
limits :savexlower :savexupper 0.0 yupper  ;builds count in "ycol-data
grid 10 10
box
xaxis 10 1
yaxis 10 1

blue histogram
hist :val-list

let [cnt 0]
repeat count :ycol-data [
     setnth :cnt :ycol-data (nth :cnt :ycol-data) / 9
     make "cnt :cnt + 1
     ]
red histogram

title "|Histogram of Noise|
xlabel "|10X Temperature (deg C)|
ylabel "Count

end

to plot-temp
ltype 1      ; black white lines
ptype 2      ; circles

make "ncol 6
make "data-list :heat-list
xcol 1
ycol 3

limits 0 xupper 0.0 70.0
make "last xupper

clean
grid 10 7
box
xaxis 10 1
yaxis 7 1

title "|Temperature (deg C) versus Time|
xlabel "|Time (seconds)|
ylabel "Temp
red
histogram

make "ncol 6
make "data-list :heat-list
xcol 1
ycol 4
green
histogram

make "ncol 6
make "data-list :heat-list
xcol 1
ycol 5
cyan
histogram

make "ncol 6
make "data-list :heat-list
xcol 1
ycol 6
magenta
histogram

make "ncol 6
make "data-list :heat-list
xcol 1
ycol 2
blue 
histogram
rel 1.05 * :last 15 label "Day
rel 1.05 * :last  5 label "Night

    if ((count :xcol-data) > 5) [
      make "t1 :elapse - 120
      make "t2 :elapse
      
      xcol 1                 ; time
      ycol 3                 ;surface temp
      select-data :t1 :t2
      ; blue
      make "slope fit-line
      make "slope 60 * :slope + 60
      make "slope-list se  se  :slope-list ((:t1 + :t2) / 2)  :slope

      make "data-list :slope-list
      make "ncol 2
      xcol 1
      ycol 2
      red
      points
      rel 0 60 draw :last 60
      rel 1.05 * :last 65 label "Rise
      rel 1.05 * :last 55  label "Fall
      ]
end



to init-packet
make "packet-bytes []
end

to packet-time :n :m
output (10 * :n) + (:m / 1000)
end

to show-packet
let [d :data-list]
repeat (count :d) 
  [ print nth 0 :d
    make "d bf :d ]
end

to packet-words :l           ; this version leaves off the checksum
  let [res []]
  let [nws (first :l) / 2 + 2]
  if ( :nws > 25 ) [ make "nws 25 ]
  dotimes [i :nws - 1][make "res se :res bf 100000 + wnth :i :l]
  output :res
end

to word-list :l
  let [res []]
  dotimes [i (wnth 0 :l) / 2][make "res se :res wnth :i + 1 :l]
  output :res
end

to wnth :i :l
  output (nth 2 * :i :l) + 256 * (nth 2 * :i + 1 :l)
end



   
